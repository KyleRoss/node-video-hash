"use strict";
const imghash = require('imghash');
const pMap = require('p-map-series');
const eventToPromise = require('event-to-promise');
const mkdir = require('make-dir');
const crypto = require('crypto');
const path = require('path');

/**
 * @typicalname video
 */
class Video {
    /**
     * Creates an instance of Video. This constructor cannot be called directly.
     * @param {Object} options Options passed from VideoHash.
     * @param {FfmpegCommand} video Instance of `FfmpegCommand` from `fluent-ffmpeg` for the video.
     */
    constructor(options, video) {
        this._opts = options;
        this._video = video;
    }
    
    /**
     * Generates the hash/fingerprint for a single video.
     * @returns {Promise<String>} The generated hash/fingerprint for the video.
     * 
     * @example 
     * const vHash = require('video-hash')({
     *     // options...
     * });
     * 
     * async function hashVideo(videoPath) {
     *     const video = vHash.video(videoPath);
     * 
     *     try {
     *         let hash = await video.hash();
     *         return hash;
     *     } catch(err) {
     *         throw err;
     *     }
     */
    async hash() {
        if(!this._video) throw new Error(`Video was not provided.`);
        const meta = await this.metadata();
        const frames = await this._captureScreenshots(meta);
        
        let captureHashes = await this._generateCaptureHashes(frames);
        
        return crypto.createHash(this._opts.hashAlgorithm).update(captureHashes.join('')).digest('hex');
    }
    
    /**
     * Returns basic metadata for a single video from `ffprobe`.
     * @returns {Promise<Object>} The `format` metadata object for the video. See [metadata](https://github.com/fluent-ffmpeg/node-fluent-ffmpeg#reading-video-metadata).
     * 
     * @example 
     * async function getMetadata(videoPath) {
     *     const video = vHash.video(videoPath);
     *     let metadata = await video.metadata();
     * }
     */
    metadata() {
        return new Promise((resolve, reject) => {
            if(!this._video) return reject(new Error(`Video was not provided.`));
            if(this._video._vhashMeta) return resolve(this._video._vhashMeta);
            
            this._video.ffprobe((err, meta) => {
                if(err) return reject(err);
                this._video._vhashMeta = meta.format;
                resolve(meta.format);
            });
        });
    }
    
    /**
     * Captures screenshots from a single video file.
     * @private 
     * @param {Object} meta The metadata object for the video file.
     * @returns {Promise<String[]>} Array of file paths to images that were captured from the video.
     */
    async _captureScreenshots(meta) {
        const count = this._calcScreenshotCount(meta.duration, this._opts.strength);
        const dest = await this._getTempDirPath(this._opts.tempDir);
        
        let promise = eventToPromise.multi(this._video, ['end'], ['error']);
        let _files = [];
        
        this._video
            .on('filenames', files => _files = files.map(name => path.join(dest, name)))
            .screenshots({
                count,
                folder: dest,
                filename: 'frame_%i.png'
            });
        
        await promise;
        promise.cancel();
        
        return _files;
    }
    
    /**
     * Calculates the number of screenshots to take of a single video.
     * @private 
     * @param {Number} duration The duration of the video in seconds.
     * @param {Number} strength Strength in which increase or decrease the number of screenshots captured.
     * @returns {Number} The number of screenshots to take of the video.
     */
    _calcScreenshotCount(duration, strength) {
        return Math.ceil(Math.ceil(duration) * strength);
    }
    
    /**
     * Creates a new directory using a base path for storing data generated by VideoHash.
     * @private 
     * @param {String} basePath Base path in which to create the new directory.
     * @returns {String} Path to the created temp directory.
     */
    _getTempDirPath(basePath) {
        return mkdir(path.join(basePath, `vhash_${Date.now()}`));
    }
    
    /**
     * Hashes an array of image paths.
     * @private 
     * @param {String[]} frames Array of image paths corresponding to the frames captured from the video.
     * @returns {Promise<String[]>} Array of hashes generated from the images.
     */
    _generateCaptureHashes(frames) {
        return pMap(frames, async frame => await imghash.hash(frame, this._opts.hashBits));
    }
}

module.exports = Video;
